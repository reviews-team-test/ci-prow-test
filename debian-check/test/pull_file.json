[
    {
        "sha": "a98f56710a8accfae891d2447ac7f07559c0b2f6",
        "filename": ".github/workflows/call-ckux-check.yml",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/peeweep-test/test-ci-check/blob/900c427f788006210c8cdcee47a7f55cdaa1c7c4/.github%2Fworkflows%2Fcall-ckux-check.yml",
        "raw_url": "https://github.com/peeweep-test/test-ci-check/raw/900c427f788006210c8cdcee47a7f55cdaa1c7c4/.github%2Fworkflows%2Fcall-ckux-check.yml",
        "contents_url": "https://api.github.com/repos/peeweep-test/test-ci-check/contents/.github%2Fworkflows%2Fcall-ckux-check.yml?ref=900c427f788006210c8cdcee47a7f55cdaa1c7c4",
        "patch": "@@ -0,0 +1,18 @@\n+name: ckuxCheck\n+on: \n+    pull_request_target:\n+        types: [opened, synchronize, reopened]\n+\n+permissions:\n+    contents: read\n+    pull-requests: read\n+    checks: write\n+\n+jobs:\n+    ckux-check:\n+        uses: kuchune/.github/.github/workflows/ckux-check.yml@develop\n+        secrets:\n+            access_token: ${{ secrets.GITHUB_TOKEN }}\n+        with:\n+            repository: ${{ github.repository }}\n+            check-type: \"static-check\"\n\\ No newline at end of file"
    },
    {
        "sha": "2d640709a4a53a6a0dad9d5538ce24f09921dec6",
        "filename": "README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/peeweep-test/test-ci-check/blob/900c427f788006210c8cdcee47a7f55cdaa1c7c4/README.md",
        "raw_url": "https://github.com/peeweep-test/test-ci-check/raw/900c427f788006210c8cdcee47a7f55cdaa1c7c4/README.md",
        "contents_url": "https://api.github.com/repos/peeweep-test/test-ci-check/contents/README.md?ref=900c427f788006210c8cdcee47a7f55cdaa1c7c4",
        "patch": "@@ -1,2 +1,3 @@\n-test_jenkins\n-3333444444\n\\ No newline at end of file\n+echo \"lshw\"1126\n+echo \"export888\"11\n+echo \"1111dmidec8ode888\""
    },
    {
        "sha": "0a162e86aba179deba5dba4830fa22b09d6601a4",
        "filename": "appitem.cpp",
        "status": "added",
        "additions": 842,
        "deletions": 0,
        "changes": 842,
        "blob_url": "https://github.com/peeweep-test/test-ci-check/blob/900c427f788006210c8cdcee47a7f55cdaa1c7c4/appitem.cpp",
        "raw_url": "https://github.com/peeweep-test/test-ci-check/raw/900c427f788006210c8cdcee47a7f55cdaa1c7c4/appitem.cpp",
        "contents_url": "https://api.github.com/repos/peeweep-test/test-ci-check/contents/appitem.cpp?ref=900c427f788006210c8cdcee47a7f55cdaa1c7c4",
        "patch": "@@ -0,0 +1,842 @@\n+// SPDX-FileCopyrightText: 2011 - 2022 UnionTech Software Technology Co., Ltd.\n+//\n+// SPDX-License-Identifier: LGPL-3.0-or-later\n+\n+#include \"appitem.h\"\n+#include \"themeappicon.h\"\n+#include \"xcb_misc.h\"\n+#include \"appswingeffectbuilder.h\"\n+#include \"utils.h\"\n+#include \"settingmanager.h\"\n+\n+#include <dde-api/eventlogger.hpp>\n+\n+#include <X11/X.h>\n+#include <X11/Xlib.h>\n+\n+#include <QPainter>\n+#include <QDrag>\n+#include <QMouseEvent>\n+#include <QApplication>\n+#include <QHBoxLayout>\n+#include <QTimeLine>\n+#include <QX11Info>\n+#include <QGSettings>\n+\n+#include <DGuiApplicationHelper>\n+\n+DGUI_USE_NAMESPACE\n+DCORE_USE_NAMESPACE\n+\n+#define APP_DRAG_THRESHOLD      20\n+\n+QPoint AppItem::MousePressPos;\n+\n+AppItem::AppItem(const QGSettings *appSettings, const QGSettings *activeAppSettings, const QGSettings *dockedAppSettings, const QDBusObjectPath &entry, QWidget *parent)\n+    : DockItem(ItemType_App, parent)\n+    , m_appSettings(appSettings)\n+    , m_activeAppSettings(activeAppSettings)\n+    , m_dockedAppSettings(dockedAppSettings)\n+    , m_appPreviewTips(nullptr)\n+    , m_itemEntryInter(new DockEntryInter(\"com.deepin.dde.daemon.Dock\", entry.path(), QDBusConnection::sessionBus(), this))\n+    , m_swingEffectView(nullptr)\n+    , m_itemAnimation(nullptr)\n+    , m_drag(nullptr)\n+    , m_retryTimes(0)\n+    , m_iconValid(true)\n+    , m_lastclickTimes(0)\n+    , m_needTip(true)\n+    , m_inOverflow(false)\n+    , m_needChangedHidePos(false)\n+    , m_overflowItemRect(QRect())\n+    , m_appIcon(QPixmap())\n+    , m_updateIconGeometryTimer(new QTimer(this))\n+    , m_retryObtainIconTimer(new QTimer(this))\n+    , m_refershIconTimer(new QTimer(this))\n+    , m_themeType(DGuiApplicationHelper::instance()->themeType())\n+    , m_entry(entry)\n+{\n+    auto *centralLayout = new QHBoxLayout;\n+    centralLayout->setMargin(0);\n+    centralLayout->setSpacing(0);\n+\n+    setObjectName(m_itemEntryInter->name());\n+    setAcceptDrops(true);\n+    setLayout(centralLayout);\n+\n+    m_id = m_itemEntryInter->id();\n+    m_active = m_itemEntryInter->isActive();\n+    m_currentWindowId = m_itemEntryInter->currentWindow();\n+\n+    m_updateIconGeometryTimer->setInterval(50);\n+    m_updateIconGeometryTimer->setSingleShot(true);\n+\n+    m_retryObtainIconTimer->setInterval(3000);\n+    m_retryObtainIconTimer->setSingleShot(true);\n+\n+    m_refershIconTimer->setInterval(1000);\n+    m_refershIconTimer->setSingleShot(false);\n+\n+    connect(m_itemEntryInter, &DockEntryInter::IsActiveChanged, this, &AppItem::activeChanged);\n+    connect(m_itemEntryInter, &DockEntryInter::IsActiveChanged, this, static_cast<void (AppItem::*)()>(&AppItem::update));\n+    connect(m_itemEntryInter, &DockEntryInter::WindowInfosChanged, this, &AppItem::updateWindowInfos, Qt::QueuedConnection);\n+    connect(m_itemEntryInter, &DockEntryInter::IconChanged, this, &AppItem::refreshIcon);\n+\n+    connect(m_retryObtainIconTimer, &QTimer::timeout, this, &AppItem::refreshIcon, Qt::QueuedConnection);\n+    connect(m_updateIconGeometryTimer, &QTimer::timeout, this, &AppItem::updateWindowIconGeometries, Qt::QueuedConnection);\n+    connect(this, &AppItem::requestUpdateEntryGeometries, this, &AppItem::updateWindowIconGeometries);\n+    connect(DWindowManagerHelper::instance(), &DWindowManagerHelper::hasBlurWindowChanged, this, [this] {\n+        hidePopup();\n+        // showHoverTips定时器设置了500ms，其他地方hidepopup会终止定时器，导致这里启动定时器后，被其他地方关掉了，所以这里延时500\n+        QTimer::singleShot(500, this, [this] {\n+            if (underMouse()) {\n+                showHoverTips();\n+            }\n+        });\n+    });\n+\n+    updateWindowInfos(m_itemEntryInter->windowInfos());\n+    refreshIcon();\n+\n+    if (m_appSettings)\n+        connect(m_appSettings, &QGSettings::changed, this, &AppItem::onGSettingsChanged);\n+    if (m_dockedAppSettings)\n+        connect(m_dockedAppSettings, &QGSettings::changed, this, &AppItem::onGSettingsChanged);\n+    if (m_activeAppSettings)\n+        connect(m_activeAppSettings, &QGSettings::changed, this, &AppItem::onGSettingsChanged);\n+\n+    connect(DGuiApplicationHelper::instance(), &DGuiApplicationHelper::themeTypeChanged, this, &AppItem::onThemeTypeChanged);\n+\n+    /** 日历 1S定时判断是否刷新icon的处理 */\n+    connect(m_refershIconTimer, &QTimer::timeout, this, &AppItem::onRefreshIcon);\n+\n+    m_repeatPresentWindowTime.start();\n+}\n+\n+/**将属于同一个应用的窗口合并到同一个应用图标\n+ * @brief AppItem::checkEntry\n+ */\n+void AppItem::checkEntry()\n+{\n+    m_itemEntryInter->Check();\n+}\n+\n+const QString AppItem::appId() const\n+{\n+    return m_id;\n+}\n+\n+bool AppItem::isValid() const\n+{\n+    return m_itemEntryInter->isValid() && !m_itemEntryInter->id().isEmpty();\n+}\n+\n+// Update _NET_WM_ICON_GEOMETRY property for windows that every item\n+// that manages, so that WM can do proper animations for specific\n+// window behaviors like minimization.\n+void AppItem::updateWindowIconGeometries()\n+{\n+    // 普通应用，使用自身item位置\n+    // 溢出应用，并且在溢出区未展开时，最小化的位置需要改变为溢出区按键的位置；溢出区展开时，使用自身item位置\n+    QRect r = m_inOverflow && m_needChangedHidePos ? m_overflowItemRect : QRect(mapToGlobal(QPoint(0, 0)), mapToGlobal(QPoint(width(), height())));\n+\n+    if (Utils::IS_WAYLAND_DISPLAY) {\n+        Q_EMIT requestUpdateItemMinimizedGeometry(r);\n+        return;\n+    }\n+\n+    if (!QX11Info::connection()) {\n+        qCWarning(DOCK_APP) << \"Update window icon geometries, QX11 info connection is null\";\n+        return;\n+    }\n+\n+    auto *xcb_misc = XcbMisc::instance();\n+\n+    for (auto it(m_windowInfos.cbegin()); it != m_windowInfos.cend(); ++it)\n+        xcb_misc->set_window_icon_geometry(it.key(), r);\n+}\n+\n+void AppItem::updateOverflowAppMinimizedGeometry(bool overflow, bool needChange, const QRect &rect)\n+{\n+    m_inOverflow = overflow;\n+    m_needChangedHidePos = needChange;\n+    m_overflowItemRect = rect;\n+    updateWindowIconGeometries();\n+}\n+\n+/**取消驻留在dock上的应用\n+ * @brief AppItem::undock\n+ */\n+void AppItem::undock()\n+{\n+    m_itemEntryInter->RequestUndock();\n+}\n+\n+QWidget *AppItem::appDragWidget()\n+{\n+    if (m_drag) {\n+        return m_drag->appDragWidget();\n+    }\n+\n+    return nullptr;\n+}\n+\n+void AppItem::setDockInfo(Dock::Position dockPosition, const QRect &dockGeometry)\n+{\n+    if (m_drag) {\n+        m_drag->appDragWidget()->setDockInfo(dockPosition, dockGeometry);\n+    }\n+}\n+\n+QString AppItem::appIconName() const\n+{\n+    return m_itemEntryInter->icon();\n+}\n+\n+QString AppItem::accessibleName()\n+{\n+    return m_itemEntryInter->name();\n+}\n+\n+quint32 AppItem::getActiveWindowId() const\n+{\n+    if (!m_itemEntryInter)\n+        return m_currentWindowId;\n+\n+    return m_itemEntryInter->currentWindow();\n+}\n+\n+void AppItem::moveEvent(QMoveEvent *e)\n+{\n+    DockItem::moveEvent(e);\n+\n+    if (m_drag) {\n+        m_drag->appDragWidget()->setOriginPos(mapToGlobal(appIconPosition()));\n+    }\n+\n+    m_updateIconGeometryTimer->start();\n+}\n+\n+void AppItem::paintEvent(QPaintEvent *e)\n+{\n+    DockItem::paintEvent(e);\n+    if (m_dragging || (m_swingEffectView != nullptr && DockDisplayMode != Fashion))\n+        return;\n+\n+    QPainter painter(this);\n+    if (!painter.isActive())\n+        return;\n+    painter.setRenderHint(QPainter::Antialiasing, true);\n+    painter.setRenderHint(QPainter::SmoothPixmapTransform, true);\n+\n+    const QRectF itemRect = rect();\n+\n+    if (DockDisplayMode == Efficient) {\n+        // draw background\n+        qreal min = qMin(itemRect.width(), itemRect.height());\n+        QRectF backgroundRect = QRectF(itemRect.x(), itemRect.y(), min, min);\n+\n+        // 图标之间的背景底色间距需要随着任务栏的变化而动态改变，避免当任务栏变大时，间距看起来很小；\n+        // 改变策略为分三挡变化，当前itemRect大小范围是[36~96]，故三挡间距为：[36~54]：2, (54~72]：3, (72~96]:4\n+        const int margin = min > 72 ? 4 : ( min > 54 ? 3 : 2);\n+        backgroundRect = backgroundRect.marginsRemoved(QMargins(margin, margin, margin, margin));\n+        backgroundRect.moveCenter(itemRect.center());\n+\n+        QPainterPath path;\n+        path.addRoundedRect(backgroundRect, 8, 8);\n+\n+        if (m_active) {\n+            if (DGuiApplicationHelper::DarkType == m_themeType) {\n+                painter.fillPath(path, QColor(255, 255, 255, 255 * 0.6));\n+                painter.setPen(QColor(0, 0, 0, 255 * 0.2));\n+            } else {\n+                painter.fillPath(path, QColor(0, 0, 0, 255 * 0.8));\n+                painter.setPen(QColor(255, 255, 255, 255 * 0.2));\n+            }\n+            painter.drawPath(path);\n+        } else if (!m_windowInfos.isEmpty()) {\n+            if (hasAttention()) {\n+                painter.fillPath(path, QColor(241, 138, 46, 255 * .8));\n+            } else {\n+                if (DGuiApplicationHelper::DarkType == m_themeType) {\n+                    painter.fillPath(path, QColor(255, 255, 255, 255 * 0.2));\n+                    painter.setPen(QColor(0, 0, 0, 255 * 0.2));\n+                } else {\n+                    painter.fillPath(path, QColor(0, 0, 0, 255 * 0.2));\n+                    painter.setPen(QColor(255, 255, 255, 255 * 0.2));\n+                }\n+                painter.drawPath(path);\n+            }\n+        }\n+    } else {\n+        if (!m_windowInfos.isEmpty()) {\n+            QPoint p;\n+            QPixmap pixmap;\n+            QPixmap activePixmap;\n+            if (DGuiApplicationHelper::DarkType == m_themeType) {\n+                m_horizontalIndicator = QPixmap(\":/indicator/resources/indicator_dark.svg\");\n+                m_verticalIndicator = QPixmap(\":/indicator/resources/indicator_dark_ver.svg\");\n+            } else {\n+                m_horizontalIndicator = QPixmap(\":/indicator/resources/indicator.svg\");\n+                m_verticalIndicator = QPixmap(\":/indicator/resources/indicator_ver.svg\");\n+            }\n+            m_activeHorizontalIndicator = QPixmap(\":/indicator/resources/indicator_active.svg\");\n+            m_activeVerticalIndicator = QPixmap(\":/indicator/resources/indicator_active_ver.svg\");\n+            switch (DockPosition) {\n+            case Top:\n+                pixmap = m_horizontalIndicator;\n+                activePixmap = m_activeHorizontalIndicator;\n+                p.setX((itemRect.width() - pixmap.width()) / 2);\n+                p.setY(1);\n+                break;\n+            case Bottom:\n+                pixmap = m_horizontalIndicator;\n+                activePixmap = m_activeHorizontalIndicator;\n+                p.setX((itemRect.width() - pixmap.width()) / 2);\n+                p.setY(itemRect.height() - pixmap.height() - 1);\n+                break;\n+            case Left:\n+                pixmap = m_verticalIndicator;\n+                activePixmap = m_activeVerticalIndicator;\n+                p.setX(1);\n+                p.setY((itemRect.height() - pixmap.height()) / 2);\n+                break;\n+            case Right:\n+                pixmap = m_verticalIndicator;\n+                activePixmap = m_activeVerticalIndicator;\n+                p.setX(itemRect.width() - pixmap.width() - 1);\n+                p.setY((itemRect.height() - pixmap.height()) / 2);\n+                break;\n+            }\n+\n+            if (m_active)\n+                painter.drawPixmap(p, activePixmap);\n+            else\n+                painter.drawPixmap(p, pixmap);\n+        }\n+    }\n+\n+    if (m_swingEffectView != nullptr)\n+        return;\n+\n+    // icon\n+    if (m_appIcon.isNull())\n+        return;\n+\n+    painter.drawPixmap(appIconPosition(), m_appIcon);\n+}\n+\n+void AppItem::mouseReleaseEvent(QMouseEvent *e)\n+{\n+    if (checkGSettingsControl()) {\n+        return;\n+    }\n+\n+    // 获取时间戳qint64转quint64，是不存在任何问题的\n+    quint64 curTimestamp = QDateTime::currentDateTime().toMSecsSinceEpoch();\n+    if ((curTimestamp - m_lastclickTimes) < 300)\n+        return;\n+\n+    m_lastclickTimes = curTimestamp;\n+\n+    // 鼠标在图标外边松开时，没必要响应点击操作\n+    QSize Size = size();\n+    qCDebug(DOCK_APP) << \"Dock size: \" << Size << \", map from global: \" << mapFromGlobal(QCursor::pos())\n+             << \", cursor pos: \" << QCursor::pos();\n+    const QRect rect { QPoint(0, 0), Size};\n+    QPoint globalPos = mapFromGlobal(QCursor::pos());\n+    if (!(globalPos.x() < 0 || globalPos.y() < 0) && !rect.contains(globalPos)) {\n+        qCWarning(DOCK_APP) << \"Global pos out of dock size, dock size: \" << Size << \", global pos: \" << globalPos;\n+        return;\n+    }\n+\n+    if (e->button() == Qt::MiddleButton) {\n+        m_itemEntryInter->NewInstance(QX11Info::getTimestamp());\n+\n+        // play launch effect\n+        if (m_windowInfos.isEmpty())\n+            playSwingEffect();\n+\n+    } else if (e->button() == Qt::LeftButton) {\n+        if (checkAndResetTapHoldGestureState() && e->source() == Qt::MouseEventSynthesizedByQt) {\n+            qCDebug(DOCK_APP) << \"Tap and hold gesture detected, ignore the synthesized mouse release event\";\n+            return;\n+        }\n+\n+        qCDebug(DOCK_APP) << \"App item clicked, name:\" << m_itemEntryInter->name()\n+                 << \", item entry interface id:\" << m_itemEntryInter->id() << \", app id:\" << m_id << \", icon:\" << m_itemEntryInter->icon();\n+\n+        if (m_itemEntryInter->windowInfos().empty()) {\n+            QString name = m_itemEntryInter->name();\n+            DDE_EventLogger::EventLoggerData data;\n+            data.tid = EVENT_LOGGER_DOCK_START_APP;\n+            data.event = \"dock_app_click\";\n+            data.target = name;\n+            data.message = {{\"appName\", name}, {\"appDesktop\", m_itemEntryInter->desktopFile()}};\n+            DDE_EventLogger::EventLogger::instance().writeEventLog(data);\n+        }\n+\n+        m_itemEntryInter->Activate(QX11Info::getTimestamp());\n+\n+        // play launch effect\n+        if (m_windowInfos.isEmpty() && DGuiApplicationHelper::isSpecialEffectsEnvironment())\n+            playSwingEffect();\n+\n+        emit hideOverflowPopup();\n+    }\n+    DockItem::mouseReleaseEvent(e);\n+}\n+\n+void AppItem::mousePressEvent(QMouseEvent *e)\n+{\n+    if (checkGSettingsControl()) {\n+        return;\n+    }\n+    m_updateIconGeometryTimer->stop();\n+    hidePopup();\n+    onResetPreview();\n+\n+    if (e->button() == Qt::LeftButton)\n+        MousePressPos = e->pos();\n+\n+    // context menu will handle in DockItem\n+    DockItem::mousePressEvent(e);\n+}\n+\n+void AppItem::mouseMoveEvent(QMouseEvent *e)\n+{\n+    e->accept();\n+\n+    // handle drag\n+    if (e->buttons() != Qt::LeftButton)\n+        return;\n+\n+    const QPoint pos = e->pos();\n+    if (!rect().contains(pos))\n+        return;\n+}\n+\n+void AppItem::presentWindows() {\n+    if (m_repeatPresentWindowTime.elapsed() > 300) {\n+        m_repeatPresentWindowTime.restart();\n+        m_itemEntryInter->PresentWindows();\n+    }\n+}\n+\n+bool AppItem::cursorInPreviewClose() const\n+{\n+    if (!m_appPreviewTips)\n+        return false;\n+\n+    return m_appPreviewTips->cursorInClose();\n+}\n+\n+void AppItem::resizeEvent(QResizeEvent *e)\n+{\n+    DockItem::resizeEvent(e);\n+\n+    stopSwingEffect();\n+\n+    refreshIcon();\n+}\n+\n+void AppItem::dragEnterEvent(QDragEnterEvent *e)\n+{\n+    if (checkGSettingsControl()) {\n+        return;\n+    }\n+\n+    // ignore drag from panel\n+    if (e->source()) {\n+        return e->ignore();\n+    }\n+\n+    // ignore request dock event\n+    QString draggingMimeKey = e->mimeData()->formats().contains(\"RequestDock\") ? \"RequestDock\" : \"text/plain\";\n+    if (QMimeDatabase().mimeTypeForFile(e->mimeData()->data(draggingMimeKey)).name() == \"application/x-desktop\") {\n+        return e->ignore();\n+    }\n+\n+    e->accept();\n+}\n+\n+void AppItem::dragMoveEvent(QDragMoveEvent *e)\n+{\n+    if (checkGSettingsControl()) {\n+        return;\n+    }\n+\n+    DockItem::dragMoveEvent(e);\n+\n+    if (m_windowInfos.isEmpty())\n+        return;\n+\n+    if (!PopupWindow->isVisible(this) || !m_appPreviewTips)\n+        showPreview();\n+}\n+\n+void AppItem::dropEvent(QDropEvent *e)\n+{\n+    QStringList uriList;\n+    const auto &mimeUrls = e->mimeData()->urls();\n+    for (const auto &uri : mimeUrls) {\n+        uriList << uri.toEncoded();\n+    }\n+\n+    qCDebug(DOCK_APP) << \"Accept drop event with URIs: \" << uriList;\n+    m_itemEntryInter->HandleDragDrop(QX11Info::getTimestamp(), uriList);\n+}\n+\n+void AppItem::leaveEvent(QEvent *e)\n+{\n+    m_hover = false;\n+    m_popupTipsDelayTimer->stop();\n+\n+    if (m_appPreviewTips) {\n+        if (m_appPreviewTips->isVisible())\n+            return m_appPreviewTips->prepareHide();\n+    }\n+    DockItem::leaveEvent(e);\n+}\n+\n+void AppItem::showHoverTips()\n+{\n+    if (checkGSettingsControl() || !m_needTip  || qApp->property(PRESENTWINDOW).toBool() || qApp->property(APP_DRAG_STATE).toBool()) {\n+        return;\n+    }\n+\n+    if (!m_windowInfos.isEmpty())\n+        return showPreview();\n+\n+    DockItem::showHoverTips();\n+}\n+\n+void AppItem::invokedMenuItem(const QString &itemId, const bool checked)\n+{\n+    Q_UNUSED(checked);\n+\n+    m_itemEntryInter->HandleMenuItem(QX11Info::getTimestamp(), itemId);\n+}\n+\n+const QString AppItem::contextMenu() const\n+{\n+    return m_itemEntryInter->menu();\n+}\n+\n+QWidget *AppItem::popupTips()\n+{\n+    if (checkGSettingsControl())\n+        return nullptr;\n+\n+    if (m_dragging)\n+        return nullptr;\n+\n+    static QPointer<TipsWidget> appNameTips;\n+    if (appNameTips.isNull()) {\n+        appNameTips = new TipsWidget(topLevelWidget());\n+    }\n+    appNameTips->setAccessibleName(\"tip\");\n+    appNameTips->setObjectName(m_itemEntryInter->name());\n+\n+    if (!m_windowInfos.isEmpty()) {\n+        Q_ASSERT(m_windowInfos.contains(m_currentWindowId));\n+        appNameTips->setText(m_windowInfos[m_currentWindowId].title.simplified());\n+    } else {\n+        appNameTips->setText(m_itemEntryInter->name().simplified());\n+    }\n+\n+    return appNameTips.data();\n+}\n+\n+bool AppItem::hasAttention() const\n+{\n+    auto it = std::find_if(m_windowInfos.constBegin(), m_windowInfos.constEnd(), [ = ] (const auto &info) {\n+        return info.attention;\n+    });\n+\n+    return (it != m_windowInfos.end());\n+}\n+\n+bool AppItem::hasWindows() const\n+{\n+    return !m_windowInfos.isEmpty();\n+}\n+\n+QPoint AppItem::appIconPosition() const\n+{\n+    const auto ratio = devicePixelRatioF();\n+    const QRectF itemRect = rect();\n+    const QRectF iconRect = m_appIcon.rect();\n+    const qreal iconX = itemRect.center().x() - iconRect.center().x() / ratio;\n+    const qreal iconY = itemRect.center().y() - iconRect.center().y() / ratio;\n+\n+    return QPoint(iconX, iconY);\n+}\n+\n+void AppItem::showPopupWindow(QWidget *const content, const bool model, const int radius)\n+{\n+    if(qApp->property(PRESENTWINDOW).toBool())\n+        return;\n+\n+    m_popupShown = true;\n+    m_lastPopupWidget = content;\n+\n+    if (model)\n+        emit requestWindowAutoHide(false);\n+\n+    DockPopupWindow *popup = PopupWindow->toTipsPopup(this);\n+    popup->setPopupRadius(radius);\n+\n+    // 设置预览界面是否开启左右两边的圆角\n+    QWidget *lastContent = popup->getContent();\n+    if (lastContent)\n+        lastContent->setVisible(false);\n+\n+    popup->resize(content->sizeHint());\n+    popup->setContent(content);\n+\n+    const QPoint p = popupMarkPoint();\n+    if (!popup->isVisible())\n+        QMetaObject::invokeMethod(popup, \"show\", Qt::QueuedConnection, Q_ARG(QPoint, p), Q_ARG(bool, model));\n+    else\n+        popup->show(p, model);\n+\n+    connect(popup, &DockPopupWindow::accept, this, &AppItem::popupWindowAccept, Qt::UniqueConnection);\n+}\n+\n+void AppItem::updateWindowInfos(const WindowInfoMap &info)\n+{\n+    m_windowInfos = info;\n+    m_currentWindowId = info.isEmpty() ? 0 :  info.firstKey();\n+    if (m_appPreviewTips)\n+        m_appPreviewTips->setWindowInfos(m_windowInfos, m_itemEntryInter->GetAllowedCloseWindows().value());\n+    m_updateIconGeometryTimer->start();\n+\n+    // process attention effect\n+    if (hasAttention()) {\n+        if (DockDisplayMode == DisplayMode::Fashion)\n+            playSwingEffect();\n+    } else {\n+        stopSwingEffect();\n+    }\n+    update();\n+\n+    if (m_currentWindowId == 0) {\n+        emit requestCloseWindow();\n+    }\n+}\n+\n+void AppItem::updateSnapSize()\n+{\n+    if (m_appPreviewTips){\n+        m_appPreviewTips->fetchSnapshots();\n+    }\n+    update();\n+}\n+\n+void AppItem::refreshIcon()\n+{\n+    if (!isVisible())\n+        return;\n+\n+    const QString icon = m_itemEntryInter->icon();\n+\n+    if (icon.isNull()) {\n+        return;\n+    }\n+\n+    const int iconSize = qMin(width(), height());\n+\n+    if (DockDisplayMode == Efficient)\n+        m_iconValid = ThemeAppIcon::getIcon(m_appIcon, icon, iconSize * 0.7, !m_iconValid);\n+    else\n+        m_iconValid = ThemeAppIcon::getIcon(m_appIcon, icon, iconSize * 0.8, !m_iconValid);\n+\n+    if (!m_refershIconTimer->isActive() && m_itemEntryInter->icon() == \"dde-calendar\") {\n+        m_refershIconTimer->start();\n+    }\n+\n+    if (!m_iconValid) {\n+        if (m_retryTimes < 10) {\n+            m_retryTimes++;\n+            qCDebug(DOCK_APP) << m_itemEntryInter->name() << \"obtain app icon(\" << icon << \")failed, retry times:\" << m_retryTimes;\n+            // Maybe the icon was installed after we loaded the caches.\n+            // QIcon::setThemeSearchPaths will force Qt to re-check the gtk cache validity.\n+            QIcon::setThemeSearchPaths(QIcon::themeSearchPaths());\n+\n+            m_retryObtainIconTimer->start();\n+        } else {\n+            // 如果图标获取失败，一分钟后再自动刷新一次（如果还是显示异常，基本需要应用自身看下为什么了）\n+            if (!m_iconValid)\n+                QTimer::singleShot(60 * 1000, this, &AppItem::refreshIcon);\n+        }\n+\n+        update();\n+\n+        return;\n+    } else if (m_retryTimes > 0) {\n+        // reset times\n+        m_retryTimes = 0;\n+    }\n+\n+    update();\n+\n+    m_updateIconGeometryTimer->start();\n+}\n+\n+void AppItem::onRefreshIcon()\n+{\n+    if (QDate::currentDate() == m_curDate)\n+        return;\n+\n+    m_curDate = QDate::currentDate();\n+    refreshIcon();\n+}\n+\n+void AppItem::onResetPreview()\n+{\n+    emit requestSetShowWindowPreviewState(false);\n+    if (m_appPreviewTips != nullptr) {\n+        m_appPreviewTips->deleteLater();\n+        m_appPreviewTips = nullptr;\n+        disconnect(m_itemEntryInter, &DockEntryInter::WindowInfosChanged, this, &AppItem::updateSnapSize);\n+    }\n+}\n+\n+void AppItem::activeChanged()\n+{\n+    m_active = !m_active;\n+    if (m_active) {\n+        emit requestActive();\n+    }\n+}\n+\n+void AppItem::showPreview()\n+{\n+    if (m_windowInfos.isEmpty())\n+        return;\n+\n+    emit requestSetShowWindowPreviewState(true);\n+\n+    m_appPreviewTips = new PreviewContainer;\n+    m_appPreviewTips->updateDockSize(DockSize);\n+    m_appPreviewTips->setWindowInfos(m_windowInfos, m_itemEntryInter->GetAllowedCloseWindows().value());\n+    m_appPreviewTips->fetchSnapshots();\n+    m_appPreviewTips->updateLayoutDirection(DockPosition);\n+\n+    connect(m_appPreviewTips, &PreviewContainer::requestActivateWindow, this, &AppItem::requestActivateWindow, Qt::QueuedConnection);\n+    connect(m_appPreviewTips, &PreviewContainer::requestPreviewWindow, this, &AppItem::requestPreviewWindow, Qt::QueuedConnection);\n+    connect(m_appPreviewTips, &PreviewContainer::requestCancelPreviewWindow, this, &AppItem::requestCancelPreview);\n+    connect(m_appPreviewTips, &PreviewContainer::requestHidePopup, this, &AppItem::hidePopup);\n+    connect(m_appPreviewTips, &PreviewContainer::requestCheckWindows, m_itemEntryInter, &DockEntryInter::Check);\n+\n+    connect(m_appPreviewTips, &PreviewContainer::requestActivateWindow, this, &AppItem::onResetPreview);\n+    connect(m_appPreviewTips, &PreviewContainer::requestCancelPreviewWindow, this, &AppItem::onResetPreview);\n+    connect(m_appPreviewTips, &PreviewContainer::requestHidePopup, this, &AppItem::onResetPreview);\n+    connect(m_itemEntryInter, &DockEntryInter::WindowInfosChanged, this, &AppItem::updateSnapSize, Qt::QueuedConnection);\n+\n+    // 预览标题显示方式的配置\n+    m_appPreviewTips->setTitleDisplayMode(SettingManager::instance()->showWindowName());\n+    showPopupWindow(m_appPreviewTips, false, 18);\n+}\n+\n+void AppItem::playSwingEffect()\n+{\n+    // NOTE(sbw): return if animation view already playing\n+    if (m_swingEffectView != nullptr)\n+        return;\n+\n+    if (rect().isEmpty())\n+        return checkAttentionEffect();\n+\n+    stopSwingEffect();\n+\n+    QPair<QGraphicsView *, QGraphicsItemAnimation *> pair =  SwingEffect(\n+                this, m_appIcon, rect(), devicePixelRatioF());\n+\n+    m_swingEffectView = pair.first;\n+    m_itemAnimation = pair.second;\n+\n+    QTimeLine *tl = m_itemAnimation->timeLine();\n+    connect(tl, &QTimeLine::stateChanged, this, [ = ](QTimeLine::State newState) {\n+        if (newState == QTimeLine::NotRunning) {\n+            m_swingEffectView->hide();\n+            layout()->removeWidget(m_swingEffectView);\n+            m_swingEffectView = nullptr;\n+            m_itemAnimation = nullptr;\n+            checkAttentionEffect();\n+        }\n+    });\n+\n+    layout()->addWidget(m_swingEffectView);\n+    tl->start();\n+}\n+\n+void AppItem::stopSwingEffect()\n+{\n+    if (m_swingEffectView == nullptr || m_itemAnimation == nullptr)\n+        return;\n+\n+    // stop swing effect\n+    m_swingEffectView->setVisible(false);\n+\n+    if (m_itemAnimation->timeLine() && m_itemAnimation->timeLine()->state() != QTimeLine::NotRunning)\n+        m_itemAnimation->timeLine()->stop();\n+}\n+\n+void AppItem::checkAttentionEffect()\n+{\n+    QTimer::singleShot(1000, this, [ = ] {\n+        if (DockDisplayMode == DisplayMode::Fashion && hasAttention())\n+            playSwingEffect();\n+    });\n+}\n+\n+void AppItem::onGSettingsChanged(const QString &key)\n+{\n+    if (key != \"enable\") {\n+        return;\n+    }\n+\n+    const QGSettings *setting = m_itemEntryInter->isDocked()\n+            ? m_dockedAppSettings\n+            : m_activeAppSettings;\n+\n+    if (setting && setting->keys().contains(\"enable\")) {\n+        const bool isEnable = !m_appSettings || (m_appSettings->keys().contains(\"enable\") && m_appSettings->get(\"enable\").toBool());\n+        setVisible(isEnable && setting->get(\"enable\").toBool());\n+    }\n+}\n+\n+bool AppItem::checkGSettingsControl() const\n+{\n+    const QGSettings *setting = m_itemEntryInter->isDocked()\n+            ? m_dockedAppSettings\n+            : m_activeAppSettings;\n+\n+    return ((m_appSettings && m_appSettings->keys().contains(\"control\") && m_appSettings->get(\"control\").toBool())\n+            || (setting && setting->keys().contains(\"control\") && setting->get(\"control\").toBool()));\n+}\n+\n+void AppItem::onThemeTypeChanged(DGuiApplicationHelper::ColorType themeType)\n+{\n+    m_themeType = themeType;\n+    update();\n+}\n+\n+// 放到最下面是因为析构函数和匿名函数会影响lcov统计单元测试的覆盖率\n+AppItem::~AppItem()\n+{\n+    stopSwingEffect();\n+}\n+\n+void AppItem::showEvent(QShowEvent *e)\n+{\n+    DockItem::showEvent(e);\n+\n+    QTimer::singleShot(0, this, [ = ] {\n+        onGSettingsChanged(\"enable\");\n+    });\n+\n+    refreshIcon();\n+}"
    },
    {
        "sha": "b23c1c5170a1c577029e052b7ae609d7b0549d27",
        "filename": "debian/test.log",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/peeweep-test/test-ci-check/blob/900c427f788006210c8cdcee47a7f55cdaa1c7c4/debian%2Ftest.log",
        "raw_url": "https://github.com/peeweep-test/test-ci-check/raw/900c427f788006210c8cdcee47a7f55cdaa1c7c4/debian%2Ftest.log",
        "contents_url": "https://api.github.com/repos/peeweep-test/test-ci-check/contents/debian%2Ftest.log?ref=900c427f788006210c8cdcee47a7f55cdaa1c7c4",
        "patch": "@@ -0,0 +1 @@\n+111111\n\\ No newline at end of file"
    },
    {
        "sha": "db254662d354178ad29e416b2ed634dfba726685",
        "filename": "dockpopupwindow.cpp",
        "status": "added",
        "additions": 402,
        "deletions": 0,
        "changes": 402,
        "blob_url": "https://github.com/peeweep-test/test-ci-check/blob/900c427f788006210c8cdcee47a7f55cdaa1c7c4/dockpopupwindow.cpp",
        "raw_url": "https://github.com/peeweep-test/test-ci-check/raw/900c427f788006210c8cdcee47a7f55cdaa1c7c4/dockpopupwindow.cpp",
        "contents_url": "https://api.github.com/repos/peeweep-test/test-ci-check/contents/dockpopupwindow.cpp?ref=900c427f788006210c8cdcee47a7f55cdaa1c7c4",
        "patch": "@@ -0,0 +1,402 @@\n+// SPDX-FileCopyrightText: 2011 - 2022 UnionTech Software Technology Co., Ltd.\n+//\n+// SPDX-License-Identifier: LGPL-3.0-or-later\n+\n+#include \"dockpopupwindow.h\"\n+#include \"utils.h\"\n+#include \"dockcontextmenu.h\"\n+#include \"constants.h\"\n+#include \"dock-constants.h\"\n+\n+#include <DForeignWindow>\n+#include <DGuiApplicationHelper>\n+#include <DPlatformWindowHandle>\n+\n+#include <QAccessible>\n+#include <QMetaObject>\n+#include <qpa/qplatformwindow.h>\n+#include <QPainter>\n+\n+DWIDGET_USE_NAMESPACE\n+\n+const double BORDER_WIDTH = 1.0;\n+\n+DockPopupWindow::DockPopupWindow(QWidget* parent, bool noFocus, bool tellWmDock)\n+    : DBlurEffectWidget(parent)\n+    , m_model(false)\n+    , m_regionInter(new DRegionMonitor(this))\n+    , m_blockPressEventTimer(new QTimer(this))\n+    , m_lastWidget(nullptr)\n+    , m_platformWindowHandle(this)\n+    , m_radius(8)\n+    , m_innerBorderColor(QColor::Invalid)\n+    , m_dockInter(new PopupDBusDock(\"com.deepin.dde.daemon.Dock\", \"/com/deepin/dde/daemon/Dock\", QDBusConnection::sessionBus(), this))\n+{\n+    compositeChanged();\n+    if (Utils::IS_WAYLAND_DISPLAY) {\n+        // 谨慎修改层级，特别要注意对锁屏的影响\n+        setAttribute(Qt::WA_NativeWindow);\n+        if (tellWmDock && windowHandle()) {\n+            windowHandle()->setProperty(\"_d_dwayland_window-type\", \"dock\");\n+        }\n+    } else {\n+        setAttribute(Qt::WA_InputMethodEnabled, false);\n+        if (noFocus) {\n+             // 这里需要覆盖窗口属性为Qt::X11BypassWindowManagerHint\n+             setWindowFlags(Qt::X11BypassWindowManagerHint);\n+        } else {\n+            // 不在任务栏显示图标\n+            setWindowFlag(Qt::Tool);\n+        }\n+    }\n+\n+    if (noFocus) {\n+        setWindowFlag(Qt::WindowDoesNotAcceptFocus);\n+        setWindowFlag(Qt::WindowStaysOnTopHint);\n+    }\n+\n+    // Fix: bug-211649, 242759 在该对象显示前调用DWindowManagerHelper::currentWorkspaceWindows会造成背景颜色异常，提前创建winId规避这个问题\n+    createWinId();\n+\n+    connect(DWindowManagerHelper::instance(), &DWindowManagerHelper::hasBlurWindowChanged, this, &DockPopupWindow::compositeChanged);\n+    connect(m_dockInter, &PopupDBusDock::OpacityChanged, this, [this] {\n+        if (Utils::hasBlurWindow()) {\n+            updateWindowOpacity();\n+        }\n+    });\n+    connect(DGuiApplicationHelper::instance(), &DGuiApplicationHelper::themeTypeChanged, this, &DockPopupWindow::updateBackgroundColor);\n+    connect(DGuiApplicationHelper::instance(), &DGuiApplicationHelper::themeTypeChanged, this, &DockPopupWindow::updateBorderColor);\n+\n+    // 阻止mouse press 事件后延时恢复，避免出现点击鼠标弹窗不消失的问题。\n+    // 因为不知道DRegionMonitor的 press 事件和qt 的 press 事件哪一个先收到\n+    // 故DRegionMonitor的的buttonPress 事件延后 100ms 处理，qt 的 press 事件延迟 200ms 重置，极限的情况也有 100ms 做缓冲。\n+    // 方法比较粗劣，有好办法欢迎修改👏\n+    m_blockPressEventTimer->setInterval(200);\n+    m_blockPressEventTimer->setSingleShot(true);\n+    connect(m_regionInter, &DRegionMonitor::buttonPress, this, [this] (const QPoint &p, const int flag) {\n+        QTimer::singleShot(100, this,  [this, p, flag](){\n+            onGlobMousePress(p, flag);\n+        });\n+    });\n+\n+    setBlendMode(BlendMode::BehindWindowBlend);\n+\n+    m_platformWindowHandle.setShadowOffset(QPoint(0, 4));\n+    m_platformWindowHandle.setShadowColor(QColor(0, 0, 0, 0.12 * 255));\n+    m_platformWindowHandle.setBorderWidth(1); // 外边框\n+\n+    updateBackgroundColor();\n+    updateBorderColor();\n+}\n+\n+DockPopupWindow::~DockPopupWindow()\n+{\n+}\n+\n+void DockPopupWindow::setEnableSystemMove(bool enable)\n+{\n+    // 禁止窗口可以被鼠标拖动\n+    m_platformWindowHandle.setEnableSystemMove(enable);\n+}\n+\n+bool DockPopupWindow::isModel() const\n+{\n+    return m_model;\n+}\n+\n+void DockPopupWindow::setContent(QWidget* content)\n+{\n+    if (m_lastWidget) {\n+        m_lastWidget->removeEventFilter(this);\n+        m_lastWidget->setVisible(false);\n+    }\n+\n+    content->installEventFilter(this);\n+\n+    QAccessibleEvent event(this, QAccessible::NameChanged);\n+    QAccessible::updateAccessibility(&event);\n+\n+    if (!content->objectName().trimmed().isEmpty())\n+        setAccessibleName(content->objectName() + \"-popup\");\n+\n+    m_lastWidget = content;\n+    content->setParent(this);\n+    content->show();\n+    setFixedSize(content->size());\n+}\n+\n+void DockPopupWindow::show(const QPoint& pos, const bool model)\n+{\n+    m_model = model;\n+    show(pos.x(), pos.y());\n+\n+    if (m_regionInter->registered()) {\n+        m_regionInter->unregisterRegion();\n+    }\n+\n+    if (m_model) {\n+        // 此处需要延迟注册，因为在wayland下，这里如果马上注册就会立刻触发m_regionInter的buttonPress信号（具体原因需要DRegionMonitor来分析）\n+        // 导致出现一系列问题，延迟注册后就不会触发buttonPress信号，保证流程正确\n+        QMetaObject::invokeMethod(m_regionInter, \"registerRegion\", Qt::QueuedConnection);\n+    }\n+}\n+\n+void DockPopupWindow::show(const int x, const int y)\n+{\n+    m_lastPoint = QPoint(x, y);\n+    setFixedSize(m_lastWidget->size());\n+\n+    QScreen* const screen = qApp->screenAt(m_lastPoint);\n+    if (!screen) {\n+        qCWarning(DOCK_APP) << \"Cannot find screen the point is located, popup window not visible !\" << m_lastPoint;\n+        DBlurEffectWidget::hide();\n+        return;\n+    }\n+\n+    const QRect screenRect = screen->geometry();\n+    Dock::Position dockPos = qApp->property(PROP_POSITION).value<Dock::Position>();\n+    if (dockPos == Dock::Position::Top || dockPos == Dock::Position::Bottom) {\n+        int lRelativeX = x - screenRect.x() - (width() / 2); // 中心点距左边屏幕距离\n+        int rRelativeX = width() / 2 - (screenRect.width() - (x - screenRect.x())); // 中心点距右边屏幕距离\n+        int absoluteX = 0;\n+        if (lRelativeX < 0) { // 超出屏幕左边\n+            absoluteX = screenRect.x();\n+        } else if (rRelativeX > 0) { // 超出屏幕右边\n+            absoluteX = screenRect.x() + screenRect.width() - width();\n+        } else {\n+            absoluteX = x - (width() / 2);\n+        }\n+        move(absoluteX, (dockPos == Dock::Position::Top) ? y : y - height());\n+    } else if (dockPos == Dock::Position::Left || dockPos == Dock::Position::Right) {\n+        int lRelativeY = y - screenRect.y() - height() / 2;\n+        int rRelativeY = y - screenRect.y() + height() / 2 - screenRect.height();\n+        int absoluteY = 0;\n+        if (lRelativeY < 0) { // 超出屏幕上边\n+            absoluteY = screenRect.y();\n+        } else if (rRelativeY > 0) { // 超出屏幕底边\n+            absoluteY = screenRect.y() + screenRect.height() - height();\n+        } else {\n+            absoluteY = y - height() / 2;\n+        }\n+        move((dockPos == Dock::Position::Left) ? x : x - width(), absoluteY);\n+    } else {\n+        qCWarning(DOCK_APP) << \"Dock position error, popup window display abnormality !\" << dockPos;\n+        move(x, y);\n+    }\n+\n+    DBlurEffectWidget::show();\n+}\n+\n+void DockPopupWindow::hide()\n+{\n+    if (m_regionInter->registered())\n+        m_regionInter->unregisterRegion();\n+\n+    DBlurEffectWidget::hide();\n+}\n+\n+void DockPopupWindow::showEvent(QShowEvent* e)\n+{\n+    DBlurEffectWidget::showEvent(e);\n+    QTimer::singleShot(1, this, &DockPopupWindow::ensureRaised);\n+}\n+\n+void DockPopupWindow::enterEvent(QEvent* e)\n+{\n+    DBlurEffectWidget::enterEvent(e);\n+    QTimer::singleShot(1, this, &DockPopupWindow::ensureRaised);\n+}\n+\n+bool DockPopupWindow::eventFilter(QObject* o, QEvent* e)\n+{\n+    if (o != m_lastWidget || e->type() != QEvent::Resize)\n+        return false;\n+\n+    // 情景：返回快捷面板后弹窗高度变小（比如从网络页面返回）/ 网络页面关闭网卡，弹窗缩小，\n+    // 此时DockPopupWindow收到 XEventMonitor 的 press 事件，判断鼠标不在弹窗内，然后隐藏了弹窗，与用户行为不符。\n+    // 故延时处理，暂时不响应 press 事件。\n+    m_blockPressEventTimer->start();\n+    // FIXME: ensure position move after global mouse release event\n+    if (isVisible()) {\n+        QTimer::singleShot(10, this, [=] {\n+            // NOTE(sbw): double check is necessary, in this time, the popup maybe already hided.\n+            if (isVisible())\n+                show(m_lastPoint, m_model);\n+        });\n+    }\n+\n+    return false;\n+}\n+\n+void DockPopupWindow::onGlobMousePress(const QPoint& mousePos, const int flag)\n+{\n+    Q_ASSERT(m_model);\n+\n+    if (m_blockPressEventTimer->isActive()) {\n+        qCDebug(DOCK_APP) << \"Press event is blocked, do not handle mouse press event\";\n+        return;\n+    }\n+\n+    if (!((flag == DRegionMonitor::WatchedFlags::Button_Left) || (flag == DRegionMonitor::WatchedFlags::Button_Right))) {\n+        return;\n+    }\n+\n+    // 场景为点击快捷面板内的菜单，且鼠标在面板外面，点击菜单时弹窗收到了 mousePress 事件，进而隐藏了弹窗。\n+    // MENU_IS_VISIBLE_OR_JUST_HIDE 属性在点击菜单100ms后重置为 false\n+    if (qApp->property(MENU_IS_VISIBLE_OR_JUST_HIDE).toBool()) {\n+        qCInfo(DOCK_APP) << \"Menu is visible or just hide, do not hide applet\";\n+        return;\n+    }\n+\n+    const QRect rect = QRect(pos(), size());\n+    if (rect.contains(mousePos)) {\n+        // 如果此时窗口没有激活，手动激活一下，否则用户无法输入\n+        if (!isActiveWindow() && !windowFlags().testFlag(Qt::WindowDoesNotAcceptFocus)) {\n+            activateWindow();\n+        }\n+        return;\n+    }\n+\n+    // 如果点击的是屏幕键盘，则不隐藏\n+    QList<Dtk::Gui::DForeignWindow*> windowList = DWindowManagerHelper::instance()->currentWorkspaceWindows();\n+    for (auto window : windowList) {\n+        if (window->wmClass() == \"onboard\" && window->handle()->geometry().contains(scalePoint(mousePos)))\n+            return;\n+    }\n+\n+    emit accept();\n+\n+    // 隐藏后取消注册，不需要再次触发buttonPress信号\n+    m_regionInter->unregisterRegion();\n+}\n+\n+void DockPopupWindow::compositeChanged()\n+{\n+    setPopupRadius(Utils::hasBlurWindow() ? m_radius : 0);\n+    updateBackgroundColor();\n+}\n+\n+void DockPopupWindow::ensureRaised()\n+{\n+    if (isVisible()) {\n+        QWidget* content = m_lastWidget;\n+        if (!content || !content->isVisible()) {\n+            this->setVisible(false);\n+        } else {\n+            raise();\n+            if (!windowFlags().testFlag(Qt::WindowDoesNotAcceptFocus))\n+                activateWindow();\n+        }\n+    }\n+}\n+\n+/**\n+ * @brief 将缩放后的点的位置按照缩放比进行放大\n+ *  之所以这么复杂，是因为qt在多屏缩放的情况下，非首屏（即topLeft为(0,0)的屏幕）上的点坐标错误\n+ *  详见QTBUG-81695\n+ * @param point\n+ * @return QPoint\n+ */\n+QPoint DockPopupWindow::scalePoint(QPoint point)\n+{\n+    const qreal pixelRatio = qApp->devicePixelRatio();\n+    QScreen* const screen = qApp->screenAt(point);\n+    if (!screen) {\n+        qCWarning(DOCK_APP) << \"Cannot find screen the point is located: \" << point;\n+        return point;\n+    }\n+\n+    const QRect& screenRect = screen->geometry();\n+\n+    qreal pointX = point.x() * pixelRatio;\n+    if (screenRect.x() != 0) {\n+        pointX = (screenRect.x() / pixelRatio + point.x() - screenRect.x()) * pixelRatio;\n+    }\n+\n+    qreal pointY = point.y() * pixelRatio;\n+    if (screenRect.y() != 0) {\n+        pointY = (screenRect.y() / pixelRatio + point.y() - screenRect.y()) * pixelRatio;\n+    }\n+\n+    return QPoint(pointX, pointY);\n+}\n+\n+void DockPopupWindow::blockMousePressEvent(bool block)\n+{\n+    m_blockPressEventTimer->start();\n+}\n+\n+void DockPopupWindow::paintEvent(QPaintEvent *event)\n+{\n+    DBlurEffectWidget::paintEvent(event);\n+\n+    // 没有模糊特效则不画边框线\n+    if (!Utils::hasBlurWindow()) {\n+        return;\n+    }\n+\n+    QPainter painter(this);\n+    painter.setRenderHint(QPainter::Antialiasing);\n+\n+    const QRectF rect = this->rect();\n+    const QRectF innerBorderRect = rect.adjusted(BORDER_WIDTH, BORDER_WIDTH, -BORDER_WIDTH, -BORDER_WIDTH);\n+    const int innerBorderRadius = (m_radius - BORDER_WIDTH) > 0 ? m_radius - BORDER_WIDTH : 0;\n+    QPainterPath innerBorderPath;\n+    innerBorderPath.addRoundedRect(innerBorderRect, innerBorderRadius, innerBorderRadius);\n+\n+    // 绘制内边框\n+    QPen pen;\n+    pen.setColor(m_innerBorderColor);\n+    pen.setWidth(BORDER_WIDTH);\n+    painter.strokePath(innerBorderPath, pen);\n+}\n+\n+void DockPopupWindow::setPopupRadius(int radius)\n+{\n+    m_radius = Utils::hasBlurWindow() ? radius : 0;\n+\n+    m_platformWindowHandle.setWindowRadius(m_radius);\n+\n+    update();\n+}\n+\n+void DockPopupWindow::updateBackgroundColor()\n+{\n+    QColor color;\n+    if (Utils::hasBlurWindow()) {\n+        if (DGuiApplicationHelper::instance()->themeType() == DGuiApplicationHelper::LightType) {\n+            color = QColor(238, 238, 238);\n+        } else {\n+            color = QColor(20, 20, 20);\n+        }\n+        setMaskColor(color);\n+        updateWindowOpacity();\n+    } else {\n+        setMaskColor(DBlurEffectWidget::AutoColor);\n+    }\n+}\n+\n+void DockPopupWindow::updateBorderColor()\n+{\n+    if (DGuiApplicationHelper::instance()->themeType() == DGuiApplicationHelper::LightType) {\n+        m_platformWindowHandle.setBorderColor(QColor(0, 0, 0, 255 * 0.06));\n+        m_innerBorderColor = QColor(255, 255, 255, 255 * 0.1);\n+    } else {\n+        m_platformWindowHandle.setBorderColor(QColor(0, 0, 0, 255 * 0.60));\n+        m_innerBorderColor = QColor(255, 255, 255, 255 * 0.10);\n+    }\n+    update();\n+}\n+\n+void DockPopupWindow::resizeEvent(QResizeEvent *event)\n+{\n+    setFixedSize(event->size());\n+\n+    DBlurEffectWidget::resizeEvent(event);\n+}\n+\n+void DockPopupWindow::updateWindowOpacity()\n+{\n+    const float dockValue = Utils::mapOpacityValue(m_dockInter->opacity());\n+    setMaskAlpha(quint8(dockValue * 255));\n+}"
    },
    {
        "sha": "22bf9c4a814059584135344009b2d168803e808f",
        "filename": "popupwindowmanager.cpp",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/peeweep-test/test-ci-check/blob/900c427f788006210c8cdcee47a7f55cdaa1c7c4/popupwindowmanager.cpp",
        "raw_url": "https://github.com/peeweep-test/test-ci-check/raw/900c427f788006210c8cdcee47a7f55cdaa1c7c4/popupwindowmanager.cpp",
        "contents_url": "https://api.github.com/repos/peeweep-test/test-ci-check/contents/popupwindowmanager.cpp?ref=900c427f788006210c8cdcee47a7f55cdaa1c7c4",
        "patch": "@@ -0,0 +1,140 @@\n+// SPDX-FileCopyrightText: 2019 - 2023 UnionTech Software Technology Co., Ltd.\n+//\n+// SPDX-License-Identifier: LGPL-3.0-or-later\n+\n+#include \"popupwindowmanager.h\"\n+#include \"dockitem.h\"\n+\n+#include <QDBusConnection>\n+#include <QApplication>\n+\n+PopupWindowManager::PopupWindowManager(QWidget* parent)\n+    : QObject(parent)\n+    , m_appletPopup(createPopupWindow(false, false))\n+    , m_tipsPopup(createPopupWindow(true, true))\n+{\n+    QDBusConnection::sessionBus().connect(\"com.deepin.dde.lockFront\", \"/com/deepin/dde/lockFront\", \"com.deepin.dde.lockFront\", \"Visible\",\n+        this, SLOT(hidePopup(bool)));\n+    m_tipsPopup->setObjectName(\"PopupWindowManager\");\n+    m_appletPopup->setEnableSystemMove(false);\n+}\n+\n+PopupWindowManager::~PopupWindowManager()\n+{\n+    delete m_appletPopup;\n+    m_appletPopup = nullptr;\n+    delete m_tipsPopup;\n+    m_tipsPopup = nullptr;\n+}\n+\n+DockPopupWindow* PopupWindowManager::appletPopup() const\n+{\n+    return m_appletPopup;\n+}\n+\n+DockPopupWindow* PopupWindowManager::toAppletPopup(DockItem* item)\n+{\n+    return toPopup(m_appletPopup, item);\n+}\n+\n+DockPopupWindow* PopupWindowManager::toTipsPopup(DockItem* item)\n+{\n+    return toPopup(m_tipsPopup, item);\n+}\n+\n+DockPopupWindow* PopupWindowManager::popup(DockItem* item) const\n+{\n+    return m_bindMapping.value(item, nullptr);\n+}\n+\n+bool PopupWindowManager::isModel(DockItem* item) const\n+{\n+    auto itemPopup = m_bindMapping.value(item, nullptr);\n+    return itemPopup ? itemPopup->isModel() : true;\n+}\n+\n+bool PopupWindowManager::existVisibleModelPopup() const\n+{\n+    return (m_appletPopup->isModel() && m_appletPopup->isVisible())\n+        || (m_tipsPopup->isModel() && m_tipsPopup->isVisible());\n+}\n+\n+void PopupWindowManager::hide(DockItem* item) const\n+{\n+    auto itemPopup = m_bindMapping.value(item, nullptr);\n+    if (itemPopup)\n+        itemPopup->hide();\n+}\n+\n+void PopupWindowManager::accept(DockItem* item) const\n+{\n+    auto itemPopup = m_bindMapping.value(item, nullptr);\n+    if (itemPopup)\n+        emit itemPopup->accept();\n+}\n+\n+bool PopupWindowManager::isVisible(DockItem* item) const\n+{\n+    auto itemPopup = m_bindMapping.value(item, nullptr);\n+    if (itemPopup)\n+        return itemPopup->isVisible();\n+\n+    return false;\n+}\n+\n+QWidget* PopupWindowManager::getContent(DockItem* item) const\n+{\n+    auto itemPopup = m_bindMapping.value(item, nullptr);\n+    if (itemPopup)\n+        return itemPopup->getContent();\n+\n+    return nullptr;\n+}\n+\n+void PopupWindowManager::show(DockItem* item, const QPoint& pos, const bool model)\n+{\n+    auto itemPopup = m_bindMapping.value(item, nullptr);\n+    if (itemPopup)\n+        itemPopup->show(pos, model);\n+}\n+\n+DockPopupWindow* PopupWindowManager::createPopupWindow(bool noFocus, bool tellWmDock) const\n+{\n+    DockPopupWindow* arrowRectangle = new DockPopupWindow(nullptr, noFocus, tellWmDock);\n+    connect(qApp, &QApplication::aboutToQuit, arrowRectangle, &DockPopupWindow::deleteLater);\n+    return arrowRectangle;\n+}\n+\n+DockPopupWindow* PopupWindowManager::toPopup(DockPopupWindow* popup, DockItem* item)\n+{\n+    for (const auto &item : m_bindMapping.keys()) {\n+        if (m_bindMapping.value(item) == popup) {\n+            m_bindMapping.remove(item);\n+        }\n+    }\n+\n+    m_bindMapping.insert(item, popup);\n+    return popup;\n+}\n+\n+void PopupWindowManager::hidePopup(bool visible)\n+{\n+    if (m_appletPopup && m_appletPopup->isVisible() && visible)\n+        m_appletPopup->hide();\n+}\n+\n+void PopupWindowManager::disconnectAccept(DockItem *item) const\n+{\n+    auto itemPopup = m_bindMapping.value(item, nullptr);\n+    if (itemPopup && item) {\n+        disconnect(itemPopup, &DockPopupWindow::accept, item, &DockItem::popupWindowAccept);\n+    }\n+}\n+\n+void PopupWindowManager::connectAccept(DockItem *item) const\n+{\n+    auto itemPopup = m_bindMapping.value(item, nullptr);\n+    if (itemPopup && item) {\n+        connect(itemPopup, &DockPopupWindow::accept, item, &DockItem::popupWindowAccept, Qt::UniqueConnection);\n+    }\n+}"
    },
    {
        "sha": "5e72f719083beb3a6ce944d691b635a8bbe0bb54",
        "filename": "popupwindowmanager.h",
        "status": "added",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/peeweep-test/test-ci-check/blob/900c427f788006210c8cdcee47a7f55cdaa1c7c4/popupwindowmanager.h",
        "raw_url": "https://github.com/peeweep-test/test-ci-check/raw/900c427f788006210c8cdcee47a7f55cdaa1c7c4/popupwindowmanager.h",
        "contents_url": "https://api.github.com/repos/peeweep-test/test-ci-check/contents/popupwindowmanager.h?ref=900c427f788006210c8cdcee47a7f55cdaa1c7c4",
        "patch": "@@ -0,0 +1,56 @@\n+// SPDX-FileCopyrightText: 2019 - 2023 UnionTech Software Technology Co., Ltd.\n+//\n+// SPDX-License-Identifier: LGPL-3.0-or-later\n+\n+#ifndef POPUPWINDOWMANAGER_H\n+#define POPUPWINDOWMANAGER_H\n+\n+#include \"dockpopupwindow.h\"\n+\n+#include <QObject>\n+#include <QPointer>\n+\n+class DockItem;\n+\n+class PopupWindowManager : public QObject\n+{\n+    Q_OBJECT\n+\n+public:\n+    enum PopupType {\n+        PopupType_Tips,\n+        PopupType_Applet\n+    };\n+\n+public:\n+    PopupWindowManager(QWidget *parent = nullptr);\n+    ~PopupWindowManager();\n+\n+    DockPopupWindow *appletPopup() const;\n+    DockPopupWindow *toAppletPopup(DockItem *item);\n+    DockPopupWindow *toTipsPopup(DockItem *item);\n+    DockPopupWindow *popup(DockItem* item) const;\n+    bool isModel(DockItem* item) const;\n+    bool existVisibleModelPopup() const;\n+    void hide(DockItem* item) const;\n+    void accept(DockItem* item) const;\n+    bool isVisible(DockItem* item) const;\n+    QWidget *getContent(DockItem* item) const;\n+    void show(DockItem* item, const QPoint &pos, const bool model = false);\n+    void disconnectAccept(DockItem *item) const;\n+    void connectAccept(DockItem *item) const;\n+\n+public Q_SLOTS:\n+    void hidePopup(bool visible);\n+\n+private:\n+    DockPopupWindow *createPopupWindow(bool noFocus, bool tellWmDock) const;\n+    inline DockPopupWindow *toPopup(DockPopupWindow *popup, DockItem *item);\n+\n+private:\n+    DockPopupWindow *m_appletPopup;\n+    DockPopupWindow *m_tipsPopup;\n+    QMap<QPointer<DockItem>, DockPopupWindow *> m_bindMapping;\n+};\n+\n+#endif"
    },
    {
        "sha": "5a0905b6a5ae5aa1d25208aa369465ee5751b637",
        "filename": "test.cpp",
        "status": "added",
        "additions": 168,
        "deletions": 0,
        "changes": 168,
        "blob_url": "https://github.com/peeweep-test/test-ci-check/blob/900c427f788006210c8cdcee47a7f55cdaa1c7c4/test.cpp",
        "raw_url": "https://github.com/peeweep-test/test-ci-check/raw/900c427f788006210c8cdcee47a7f55cdaa1c7c4/test.cpp",
        "contents_url": "https://api.github.com/repos/peeweep-test/test-ci-check/contents/test.cpp?ref=900c427f788006210c8cdcee47a7f55cdaa1c7c4",
        "patch": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (C) 2019 ~ 2022 Uniontech Software Technology Co.,Ltd.\n+ *\n+ * Author:     libao <libao@uniontech.com>\n+ *\n+ * Maintainer: libao <libao@uniontech.com>\n+ */\n+#include \"policy_common.h\"\n+#include \"consts.h\"\n+#include \"filecontent.h\"\n+#include \"desktop_shortcut.h\"\n+#include \"scms_interface.h\"\n+#include <QCryptographicHash>\n+#include <QJsonDocument>\n+#include <QMimeDatabase>\n+#include <QJsonObject>\n+#include <QJsonArray>\n+#include <QProcess>\n+#include <QDebug>\n+#include <QUrl>\n+#include <QList>\n+#include <QPair>\n+using namespace std;\n+using namespace udcp;\n+using namespace udcp::base;\n+const char *DesktopShortcut_Key = \"desktop_shortcuts_list\";\n+DesktopShortCutPlugin::DesktopShortCutPlugin(QObject *parent)\n+    : QObject(parent)\n+{\n+}\n+int DesktopShortCutPlugin::pluginType()\n+{\n+    return PolicyPlugin;\n+}\n+QByteArray DesktopShortCutPlugin::pluginIds()\n+{\n+    QJsonArray arr = QJsonArray() << DesktopShortcut_Key;\n+    return QJsonDocument(arr).toJson(QJsonDocument::Compact);\n+}\n+void DesktopShortCutPlugin::init()\n+{\n+}\n+void DesktopShortCutPlugin::runPolicy(QByteArray &result, const QByteArray &config)\n+{\n+    const QMap<QString, QString> &configMap = PolicyCommon::policyJsonToMap(config);\n+    if (!configMap.contains(DesktopShortcut_Key)) {\n+        reportFeedback(result, PolicySuccess);\n+        return;\n+    }\n+    QString host, port;\n+    FileContent::getHostAndPort(host, port);\n+    const QJsonArray &array = QJsonDocument::fromJson(configMap.value(DesktopShortcut_Key).toUtf8()).array();\n+    QVector<QPair<QString, QString>> extraInfo;\n+    extraInfo.reserve(array.size());\n+    QStringList urls;\n+    QList<QString> ls;\n+    for (const auto &ele : array) {\n+        const QJsonObject &object = ele.toObject();\n+        // 快捷方式名称\n+        const QString &name = object.value(\"name\").toString();\n+        // 快捷方式链接\n+        const QString &url = object.value(\"url\").toString();\n+        // 图标下载路径\n+        const QString &downloadUrl = kUrlHead.arg(host).arg(port) + object.value(\"iconPath\").toString();\n+        extraInfo << QPair<QString, QString>(name, url);\n+        urls << downloadUrl;\n+    }\n+    ScmsInterface inter(ScmsServiceName, ScmsServicePath, QDBusConnection::systemBus());\n+    inter.setTimeout(3600 * 1000);\n+    QDBusPendingReply<QStringList> reply = inter.Download(urls, QDir::homePath() + \"/.cache/udcp/desktop-shortcut\");\n+    QStringList sm = reply.value();\n+    if (reply.isError() || sm.isEmpty()) {\n+        reportFeedback(result, PolicyFailed);\n+        return;\n+    }\n+    auto ret = generateDesktopFiles(sm, extraInfo);\n+    reportFeedback(result, ret ? PolicySuccess : PolicyFailed);\n+}\n+int DesktopShortCutPlugin::domainBackup()\n+{\n+    return 0;\n+}\n+int DesktopShortCutPlugin::domainRestore()\n+{\n+    return 0;\n+}\n+void DesktopShortCutPlugin::reportFeedback(QByteArray &result, PolicyErrorCode code) const\n+{\n+    QJsonObject feedback;\n+    feedback.insert(DesktopShortcut_Key, code);\n+    result = QJsonDocument(feedback).toJson(QJsonDocument::Compact);\n+}\n+static inline QPair<bool, QString> exec(const QString &program, const QStringList &arguments)\n+{\n+    QProcess process;\n+    process.start(program, arguments);\n+    if (process.waitForFinished()) {\n+        return {true, process.readAllStandardOutput()};\n+    }\n+    qWarning() << \"failed to execute command:\" << program << \"with arguments:\" << arguments << \", reason:\" << process.errorString();\n+    return {false, {}};\n+}\n+static inline QString createDesktopFilename(const QString &name, const QString &url)\n+{\n+    auto hash = QCryptographicHash::hash(QString(name + url).toUtf8(), QCryptographicHash::Md5);\n+    return QString(hash.toHex()) + \".desktop\";\n+}\n+bool DesktopShortCutPlugin::generateDesktopFile(const QString &iconFile, const QString &name, const QString &urlStr) const\n+{\n+    if (name.isEmpty()) {\n+        qWarning() << \"desktop shortcut name is empty\";\n+        return false;\n+    }\n+    QUrl url(urlStr);\n+    if (!url.isValid()) {\n+        qWarning() << \"invalid desktop shortcut url:\" << urlStr;\n+        return false;\n+    }\n+    // url 指向非 HTTP HTTPS 时不处理\n+    // 因为文管不支持 Type=Link，使用 xdg-open 打开，所以必须有这个校验\n+    if (url.scheme() != \"http\" and url.scheme() != \"https\") {\n+        qWarning() << \"invalid url scheme:\" << urlStr;\n+        return false;\n+    }\n+    // 图标文件类型判断\n+    QMimeDatabase db;\n+    if (!db.mimeTypeForFile(iconFile).name().startsWith(\"image/\")) {\n+        qWarning() << \"incorrect icon file format:\" << iconFile;\n+        return false;\n+    }\n+    auto resp = exec(\"xdg-user-dir\", {\"DESKTOP\"});\n+    if (!resp.first) {\n+        qWarning() << \"failed to get user desktop dir\";\n+        return false;\n+    }\n+    auto desktopDir = resp.second.trimmed();\n+    // 于bug170289，文件唯一性由名称+链接确认\n+    auto desktopFileName = createDesktopFilename(name, urlStr);\n+    auto desktopFilePath = FileContent::join(desktopDir, desktopFileName);\n+    QString content;\n+    content += \"[Desktop Entry]\\n\";\n+    content += QString(\"Name=%1\\n\").arg(name);\n+    content += QString(\"Icon=%1\\n\").arg(iconFile);\n+    content += QString(\"Exec=xdg-open %1\\n\").arg(urlStr);\n+    content += \"Categories=Network\\n\";\n+    content += \"StartupNotify=false\\n\";\n+    content += \"Terminal=false\\n\";\n+    content += \"Type=Application\\n\";\n+    content += \"X-Deepin-CreatedBy=udcp\\n\";\n+    auto ok = FileContent::writeTo(desktopFilePath, content.toUtf8());\n+    if (!ok) {\n+        qWarning() << \"failed to create the desktop file:\" << desktopFilePath;\n+        return false;\n+    }\n+    return true;\n+}\n+bool DesktopShortCutPlugin::generateDesktopFiles(const QStringList &ls, const QVector<QPair<QString, QString>> &extra)\n+{\n+    Q_ASSERT(ls.size() == extra.size());\n+    for (auto i = 0; i < ls.size(); ++i) {\n+        const auto &iconFile = ls[i];\n+        const auto &name = extra[i].first;\n+        const auto &url = extra[i].second;\n+        if (!generateDesktopFile(iconFile, name, url))\n+            return false;\n+    }\n+    return true;\n+}\n\\ No newline at end of file"
    },
    {
        "sha": "75b30d975244322af37f5da95b4d23fd0431fcfb",
        "filename": "test.go",
        "status": "modified",
        "additions": 23,
        "deletions": 6,
        "changes": 29,
        "blob_url": "https://github.com/peeweep-test/test-ci-check/blob/900c427f788006210c8cdcee47a7f55cdaa1c7c4/test.go",
        "raw_url": "https://github.com/peeweep-test/test-ci-check/raw/900c427f788006210c8cdcee47a7f55cdaa1c7c4/test.go",
        "contents_url": "https://api.github.com/repos/peeweep-test/test-ci-check/contents/test.go?ref=900c427f788006210c8cdcee47a7f55cdaa1c7c4",
        "patch": "@@ -1,9 +1,26 @@\n package main\n-import \"fmt\"\n+\n+import (\n+    \"errors\"\n+    \"fmt\"\n+    \"math\"\n+)\n+\n+func circleArea(radius float64) (float64, error) {\n+    if radius < 0 { \t\t// 如果小于0则运行以下\n+        return 0, errors.New(\"Area calculation failed, radius is less than zero\")\n+    }\n+    return math.Pi * radius * radius, nil\n+}\n+\n func main() {\n-    var a string = \"Runoob\"\n-    fmt.Println(a)\n+    radius := -10.00\n+    area, err := circleArea(radius)\n+    if err != nil { \t\t// 如果为空\n+        fmt.Println(err)\n+        return\n+    }\n+    fmt.Printf(\"Area of circle %0.2f\", area)\n+}\n \n-    var d int = 1, 2\n-    fmt.rintln(b, c)\n-}\n\\ No newline at end of file\n+// Area calculation failed, radius is less than zero"
    },
    {
        "sha": "d9c331e0db49c8b9fc0352efd05c89b006cbc622",
        "filename": "test.sh",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/peeweep-test/test-ci-check/blob/900c427f788006210c8cdcee47a7f55cdaa1c7c4/test.sh",
        "raw_url": "https://github.com/peeweep-test/test-ci-check/raw/900c427f788006210c8cdcee47a7f55cdaa1c7c4/test.sh",
        "contents_url": "https://api.github.com/repos/peeweep-test/test-ci-check/contents/test.sh?ref=900c427f788006210c8cdcee47a7f55cdaa1c7c4",
        "patch": "@@ -0,0 +1,3 @@\n+# !/bin/sh\n+\n+echo $name\n\\ No newline at end of file"
    }
]